#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>

//server code!!

int startup(int _port, const char *_ip)
{
	//listen sock
	int sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock < 0){
		perror("socket");
		exit(1);
	}

	int opt = 1;
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	struct sockaddr_in local;
	local.sin_family = AF_INET;
	local.sin_port   = htons(_port);
	local.sin_addr.s_addr = inet_addr(_ip);
	socklen_t len = sizeof(local);

	if( bind(sock, (struct sockaddr*)&local, len) < 0 ){
		perror("bind");
		exit(2);
	}

	if( listen(sock, 5) < 0 ){
		perror("listen");
		exit(3);
	}

	return sock;
}

int main(int argc, char *argv[])
{
	if(argc != 3){
		printf("Usage: %s [local_ip] [local_port]\n", argv[0]);
		return 3;
	}

	int listen_sock = startup(atoi(argv[2]), argv[1]);

	struct sockaddr_in remote;
	socklen_t len = sizeof(struct sockaddr_in);

	while(1){
		int sock = accept(listen_sock, \
				(struct sockaddr*)&remote, &len);
		if(sock < 0){
			perror("accept");
			continue;
		}

		printf("get a client, ip: %s, port: %d\n", \
				inet_ntoa(remote.sin_addr),\
				ntohs(remote.sin_port));
		//method 2
		pid_t id = fork();
		if(id < 0){
			close(sock);
			perror("fork");
		}else if( id == 0 ){//child
			if(fork() > 0){ 
				exit(1);
			}
      //孙子进程为孤儿进程，会被1号进程回收			
      close(listen_sock);
	    	char buf[1024];
	    	while(1){
	    		ssize_t _s = read(sock, buf, sizeof(buf)-1);
	    		if( _s > 0 ){
	    			buf[_s] = 0;
	    			printf("client# %s\n", buf);
	    		}else{
	    			printf("client is quit!\n");
	    			break;
	    		}
		    }
	        close(sock);
			exit(0);
		}else{ //father
			close(sock);
			//while( waitpid(-1, NULL, WNOHANG) > 0 );
		}

	//  method 1
	//	char buf[1024];
	//	while(1){
	//		ssize_t _s = read(sock, buf, sizeof(buf)-1);
	//		if( _s > 0 ){
	//			buf[_s] = 0;
	//			printf("client# %s\n", buf);
	//		}else{
	//			printf("client is quit!\n");
	//			break;
	//		}
	//	}
	//	close(sock);
	}

	return 0;
}


